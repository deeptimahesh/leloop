{"version":3,"file":"component---src-pages-blog-markdown-remark-frontmatter-slug-jsx-b75e355170f0b3097f1d.js","mappings":"kKAIe,SAASA,EAAkB,GAAW,IAAX,KAAEC,GAAM,EAChD,MAGMC,EAHQD,EAAKE,kBAAkBC,MAAMC,KAAIC,GAAQA,EAAKC,OAGjCC,QAAO,CAACC,EAAKC,KACtC,MAAMC,EAAOD,EAAKE,YAAYD,KAS9B,OARKF,EAAIE,KACPF,EAAIE,GAAQ,CAAEE,UAAW,KAAMC,QAAS,KAEtCJ,EAAKE,YAAYC,UACnBJ,EAAIE,GAAME,UAAYH,EAEtBD,EAAIE,GAAMG,QAAQC,KAAKL,GAElBD,CAAG,GACT,CAAC,IAGE,EAACO,EAAc,EAACC,IAAoBC,EAAAA,EAAAA,UAAS,CAAC,GAkCpD,OAhCAC,EAAAA,EAAAA,YAAU,KAER,MAqBMC,EAAmB,CAAC,EAC1BC,OAAOC,KAAKpB,GAAcqB,SAAQZ,IAChCT,EAAaS,GAAMG,QAAQS,SAAQC,IACjCJ,EAAiBI,EAAOC,IAxBNC,KACpB,GAAsB,oBAAXC,OAAwB,CACjC,MAAMX,EAAgB,CAAC,EAavB,OAZe,IAAIY,WACAC,gBAAgBH,EAAM,aACpBI,iBAAiB,MAC7BP,SAAQ,CAACQ,EAASC,KACzB,IAAIC,EAAcF,EAAQG,mBACtBC,EAAa,GACjB,KAAOF,GAAuC,OAAxBA,EAAYG,SAChCD,GAAcF,EAAYI,UAC1BJ,EAAcA,EAAYC,mBAE5BlB,EAAc,aAAYgB,EAAQ,IAAOG,CAAU,IAE9CnB,CACT,CACA,MAAO,CAAC,CAAC,EAOuBsB,CAAad,EAAOE,KAAK,GACvD,IAEJT,EAAiBG,EAAiB,GACjC,CAAClB,IAGF,2BACGmB,OAAOC,KAAKpB,GAAcG,KAAIM,IAC7B,MAAM,UAAEE,EAAS,QAAEC,GAAYZ,EAAaS,GAC5C,IAAKE,EAAW,OAAO,KACvB,MAAM,YAAED,EAAW,KAAEc,GAASb,EAC9B,OACE,uBAAK0B,IAAK1B,EAAUY,IAClB,0BAAKb,EAAY4B,OACjB,0BAAK5B,EAAY6B,MACjB,uBAAKC,wBAAyB,CAAEC,OAAQjB,KACvCd,EAAYC,WACX,2BACE,0BAAI,aACJ,0BACGD,EAAYC,UAAUR,KAAI,CAACuC,EAAUZ,IACpC,sBAAIO,IAAKP,GACP,yBAAIY,GACH9B,EAAQT,KAAImB,IAAW,IAAD,EACrB,MAAMqB,EAAqC,QAA3B,EAAG7B,EAAcQ,EAAOC,WAAG,aAAxB,eAAuCO,EAAQ,IAClE,OAAOa,EACL,uBAAKN,IAAKf,EAAOC,IACf,8BAASD,EAAOZ,YAAYkC,KAAK,KACjC,uBAAKJ,wBAAyB,CAAEC,OAAQE,MAExC,IAAI,SAOhB,IAKhB,C","sources":["webpack://le-loop/./src/pages/blog/{markdownRemark.frontmatter__slug}.jsx"],"sourcesContent":["import React, { useEffect, useState } from \"react\"\nimport { graphql } from \"gatsby\"\nimport \"../styles/styles.css\"\n\nexport default function BlogPostsTemplate({ data }) {\n  const posts = data.allMarkdownRemark.edges.map(edge => edge.node)\n\n  // Group posts by slug\n  const groupedPosts = posts.reduce((acc, post) => {\n    const slug = post.frontmatter.slug\n    if (!acc[slug]) {\n      acc[slug] = { questions: null, answers: [] }\n    }\n    if (post.frontmatter.questions) {\n      acc[slug].questions = post\n    } else {\n      acc[slug].answers.push(post)\n    }\n    return acc\n  }, {})\n\n  // State to hold parsed answers\n  const [parsedAnswers, setParsedAnswers] = useState({})\n\n  useEffect(() => {\n    // Function to parse HTML content to separate answers\n    const parseAnswers = (html) => {\n      if (typeof window !== \"undefined\") {\n        const parsedAnswers = {}\n        const parser = new DOMParser()\n        const doc = parser.parseFromString(html, 'text/html')\n        const headings = doc.querySelectorAll('h3')\n        headings.forEach((heading, index) => {\n          let nextElement = heading.nextElementSibling\n          let answerHTML = ''\n          while (nextElement && nextElement.tagName !== 'H3') {\n            answerHTML += nextElement.outerHTML\n            nextElement = nextElement.nextElementSibling\n          }\n          parsedAnswers[`Question ${index + 1}`] = answerHTML\n        })\n        return parsedAnswers\n      }\n      return {}\n    }\n\n    // Parse answers for each post\n    const newParsedAnswers = {}\n    Object.keys(groupedPosts).forEach(slug => {\n      groupedPosts[slug].answers.forEach(answer => {\n        newParsedAnswers[answer.id] = parseAnswers(answer.html)\n      })\n    })\n    setParsedAnswers(newParsedAnswers)\n  }, [groupedPosts])\n\n  return (\n    <div>\n      {Object.keys(groupedPosts).map(slug => {\n        const { questions, answers } = groupedPosts[slug]\n        if (!questions) return null\n        const { frontmatter, html } = questions\n        return (\n          <div key={questions.id}>\n            <h1>{frontmatter.title}</h1>\n            <h2>{frontmatter.date}</h2>\n            <div dangerouslySetInnerHTML={{ __html: html }} />\n            {frontmatter.questions && (\n              <div>\n                <h3>Questions</h3>\n                <ul>\n                  {frontmatter.questions.map((question, index) => (\n                    <li key={index}>\n                      <p>{question}</p>\n                      {answers.map(answer => {\n                        const answerHtml = parsedAnswers[answer.id]?.[`Question ${index + 1}`]\n                        return answerHtml ? (\n                          <div key={answer.id}>\n                            <strong>{answer.frontmatter.name}:</strong>\n                            <div dangerouslySetInnerHTML={{ __html: answerHtml }} />\n                          </div>\n                        ) : null\n                      })}\n                    </li>\n                  ))}\n                </ul>\n              </div>\n            )}\n          </div>\n        )\n      })}\n    </div>\n  )\n}\n\nexport const pageQuery = graphql`\n  query {\n    allMarkdownRemark {\n      edges {\n        node {\n          id\n          html\n          frontmatter {\n            date(formatString: \"MMMM DD, YYYY\")\n            slug\n            title\n            questions\n            name\n          }\n        }\n      }\n    }\n  }\n`\n"],"names":["BlogPostsTemplate","data","groupedPosts","allMarkdownRemark","edges","map","edge","node","reduce","acc","post","slug","frontmatter","questions","answers","push","parsedAnswers","setParsedAnswers","useState","useEffect","newParsedAnswers","Object","keys","forEach","answer","id","html","window","DOMParser","parseFromString","querySelectorAll","heading","index","nextElement","nextElementSibling","answerHTML","tagName","outerHTML","parseAnswers","key","title","date","dangerouslySetInnerHTML","__html","question","answerHtml","name"],"sourceRoot":""}